# Learning Journal - November 2024

## 目次
- [12月1日](#12月1日)
- [12月2日](#12月2日)
- [12月3日](#12月3日)
- [12月4日](#12月4日)
- [12月5日](#12月5日)
- [12月6日](#12月6日)
- [12月7日](#12月7日)
- [12月8日](#12月8日)
- [12月9日](#12月9日)

## 12月1日
[実用Go言語](https://www.oreilly.co.jp/books/9784873119694/)

### 2章 定義型
#### 2.1 型を定義してデータの不整合を防止する
##### 2.1.1 Goにおける型の定義

## 12月2日
[mizchiさんによる 「LAPRAS 公開パフォーマンスチューニング 」~調査編~](https://lapras.connpass.com/event/337670/)

## 12月3日
体調不良のためなし、悔しい

## 12月4日
体調不良のためなし、明日こそは
やらないと1年草生やす意味がない

## 12月5日
[実用Go言語](https://www.oreilly.co.jp/books/9784873119694/)

すこしでもやる
#### 2.2　既存のデータ型を拡張する
##### 2.2.1　メソッドを追加して組み込み型を拡張する
##### 2.2.2　拡張した組み込み型で、元となる基底型の挙動を利用する
##### 2.2.3　ファクトリー関数を用意して定義した型を使いやすくする

## 12月6日

[実用Go言語](https://www.oreilly.co.jp/books/9784873119694/)
#### 2.3 定義型を作成してアプリケーションドメインに対応する
##### 2.3.1　スライスへの型定義
##### 2.3.2　値への型定義
##### 2.3.3　列挙への型定義
##### 2.3.4　構造体への型定義
#### 2.4　型の変換
##### 2.4.1　型変換（type conversion）によって型をキャストする
#### 2.5　機密情報を扱うフィールドを定義して出力書式をカスタマイズする 
##### 2.5.1　実装方法

## 12月7日
[実用Go言語](https://www.oreilly.co.jp/books/9784873119694/)

すこしでもやる
### 3章　構造体
#### 3.1　構造体の基本的な使い方
#### 3.2　構造体をインスタンス化する3つの方法
##### 3.2.1　ファクトリー関数

## 12月8日
[実用Go言語](https://www.oreilly.co.jp/books/9784873119694/)


#### 3.3　構造体にメソッドを定義する 
##### 3.3.1　値レシーバーとポインターレシーバーのどちらを使えば良いか
##### 3.3.2　レシーバーはnilでもメソッドは呼べる 
##### 3.3.3　インスタンスからメソッドを取り出して関数型として使う 
##### 3.3.4　クロージャを使ってメソッドを再現する 
##### 3.3.5　ジェネリクスとメソッド 
#### 3.4　構造体の埋め込みで共通部分を使いまわす 
#### 3.5　タグを使って構造体にメタデータを埋め込む 
##### 3.5.1　タグの記法 

## 12月9日

#### 3.6 構造体を設計するポイント
##### 3.6.1　ポインター型として扱う必要があるケース 
##### 3.6.2　値として扱える場合 
##### 3.6.3　ミュータブルな構造体とイミュータブルな構造体 
##### 3.6.4　ゼロ値の動作を保証するかどうか 
##### 3.6.5　実装方法を選択するポイント

#### 3.9　構造体とオブジェクト指向の違いを知る 
##### 3.9.1　構造体の用途 
##### 3.9.2　構造体の埋め込みは継承ではない 
##### 3.9.3　テンプレートメソッドパターンではなく、ストラテジーパターン 
##### 3.9.4　あえてオーバーライドを実装する

### 4章　インタフェース
#### 4.1　柔軟なコードを書くインタフェースの利用法
##### 4.1.1　まとめ
#### 4.2　あらゆる型のデータを格納する any

